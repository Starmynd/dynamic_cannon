<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Dynamic Cannon</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- Added Google Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      touch-action: none;
      font-family: 'Press Start 2P', cursive; /* Applied new font */
    }
    #gameContainer {
      position: relative;
      border: 5px solid #000; /* Border around the game area */
    }
    #gameCanvas {
      display: block;
      background: #87CEEB;
    }
    #gameInfo {
      position: absolute;
      bottom: 70px;
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 10px;
      font-size: 1em;
      color: #000;
      border: 3px solid #000; /* Border around the interface box */
      background-color: rgba(255, 255, 255, 0.8); /* Semi-transparent background */
      box-sizing: border-box;
    }
    #shootButton {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 70px;
      font-size: 1.5em;
      background-color: #4CAF50;
      color: white;
      border: none;
      outline: none;
      cursor: pointer;
      font-family: 'Press Start 2P', cursive;
    }
    #shootButton:active {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="gameInfo">
      <div id="leftInfo">Round: 1 | Time: 90</div>
      <div id="rightInfo">Shots: 20 | Score: 0</div>
    </div>
    <button id="shootButton">Shoot</button>
  </div>
  <!-- Background music -->
  <audio id="backgroundMusic" src="https://www.bensound.com/bensound-music/bensound-buddy.mp3" loop></audio>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');

    function resizeCanvas() {
      const container = document.getElementById('gameContainer');
      canvas.width = window.innerWidth - 10; // Adjusted for border
      canvas.height = window.innerHeight - 80; // Adjusted for border and button height
      container.style.width = canvas.width + 'px';
      container.style.height = (canvas.height + 70) + 'px'; // Including button height
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    class Cannon {
      constructor() {
        this.width = canvas.width * 0.08;
        this.height = canvas.height * 0.05;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height - this.height;
        this.speed = canvas.width * 0.003;
        this.direction = 1;
      }
      update() {
        this.x += this.speed * this.direction;
        if (this.x <= 0) {
          this.x = 0;
          this.direction *= -1;
        }
        if (this.x + this.width >= canvas.width) {
          this.x = canvas.width - this.width;
          this.direction *= -1;
        }
      }
      draw() {
        // Draw tank body
        context.fillStyle = '#2F4F4F'; // Dark green military color
        context.fillRect(this.x, this.y, this.width, this.height);
        // Draw tank turret
        context.fillRect(this.x + this.width * 0.4, this.y - this.height * 0.5, this.width * 0.2, this.height * 0.5);
        // Draw tank barrel
        context.fillRect(this.x + this.width * 0.48, this.y - this.height, this.width * 0.04, this.height * 0.5);
        // Draw tank tracks
        context.fillStyle = '#000';
        context.fillRect(this.x, this.y + this.height, this.width, this.height * 0.2);
      }
    }

    class Wagon {
      constructor() {
        this.width = canvas.width * 0.15;
        this.height = canvas.height * 0.05;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height * 0.55;
        this.speed = canvas.width * 0.002;
        this.direction = 1;
      }
      update() {
        this.x += this.speed * this.direction;
        if (this.x <= 0) {
          this.x = 0;
          this.direction *= -1;
        }
        if (this.x + this.width >= canvas.width) {
          this.x = canvas.width - this.width;
          this.direction *= -1;
        }
      }
      draw() {
        context.strokeStyle = '#000';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(this.x + this.width / 2, 0);
        context.lineTo(this.x + this.width / 2, this.y);
        context.stroke();

        context.fillStyle = '#8B4513';
        context.fillRect(this.x, this.y, this.width, this.height);

        context.fillStyle = '#555';
        context.fillRect(this.x, this.y + this.height, this.width, canvas.height * 0.01);
      }
    }

    class Shell {
      constructor(x, y) {
        this.radius = canvas.width * 0.015;
        this.x = x;
        this.y = y;
        this.speedY = -canvas.height * 0.008;
        this.bounced = false;
        this.bouncedFromUpperBeam = false;
        this.active = true;
      }
      update() {
        this.y += this.speedY;
        if (this.y + this.radius * 2 < 0 || this.y - this.radius > canvas.height) {
          this.active = false;
          shellOnScreen = false; // Allow shooting again
        }
      }
      draw() {
        context.fillStyle = '#000';
        context.beginPath();
        context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        context.fill();
      }
    }

    class Beam {
      constructor() {
        this.width = canvas.width * 0.8;
        this.height = canvas.height * 0.01;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height * 0.1;
      }
      draw() {
        context.fillStyle = '#555';
        context.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    class Cloud {
      constructor(x, y, scale, speed) {
        this.x = x;
        this.y = y;
        this.scale = scale;
        this.speed = speed;
      }
      update() {
        this.x += this.speed;
        if (this.x - 100 * this.scale > canvas.width) {
          this.x = -100 * this.scale;
        }
      }
      draw() {
        context.fillStyle = '#FFF';
        context.beginPath();
        context.arc(this.x, this.y, 30 * this.scale, Math.PI * 0.5, Math.PI * 1.5);
        context.arc(this.x + 30 * this.scale, this.y - 30 * this.scale, 30 * this.scale, Math.PI * 1, Math.PI * 1.85);
        context.arc(this.x + 60 * this.scale, this.y - 20 * this.scale, 20 * this.scale, Math.PI * 1.37, Math.PI * 1.91);
        context.arc(this.x + 80 * this.scale, this.y, 30 * this.scale, Math.PI * 1.5, Math.PI * 0.5);
        context.closePath();
        context.fill();
      }
    }

    class Mountain {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      draw() {
        context.fillStyle = '#A0522D';
        context.beginPath();
        context.moveTo(this.x, this.y);
        context.lineTo(this.x + this.width / 2, this.y - this.height);
        context.lineTo(this.x + this.width, this.y);
        context.closePath();
        context.fill();

        context.fillStyle = '#FFF';
        context.beginPath();
        context.moveTo(this.x + this.width / 2, this.y - this.height);
        context.lineTo(this.x + this.width * 0.6, this.y - this.height * 0.8);
        context.lineTo(this.x + this.width * 0.4, this.y - this.height * 0.8);
        context.closePath();
        context.fill();
      }
    }

    let shells = [];
    let clouds = [];
    let mountains = [];
    let cannon;
    let wagon;
    let upperBeam;

    let shotsLeft = 20;
    let score = 0;
    let round = 1;
    let timeLeft = 90;
    let maxRounds = 10;

    let gameOver = false;
    let shellOnScreen = false;

    let gameTimer;

    function initGame() {
      cannon = new Cannon();
      wagon = new Wagon();
      upperBeam = new Beam();

      clouds = [];
      for (let i = 0; i < 5; i++) {
        let x = Math.random() * canvas.width;
        let y = canvas.height * 0.1 + Math.random() * canvas.height * 0.2;
        let scale = 0.5 + Math.random() * 0.5;
        let speed = 0.2 + Math.random() * 0.3;
        clouds.push(new Cloud(x, y, scale, speed));
      }

      mountains = [];
      let mountainWidth = canvas.width / 4;
      let mountainHeight = canvas.height / 3;
      mountains.push(new Mountain(canvas.width * 0.1, canvas.height, mountainWidth, mountainHeight));
      mountains.push(new Mountain(canvas.width * 0.4, canvas.height, mountainWidth, mountainHeight * 1.2));
      mountains.push(new Mountain(canvas.width * 0.7, canvas.height, mountainWidth, mountainHeight * 0.8));

      updateGameInfo();
      startTimer();

      // Start background music
      const bgMusic = document.getElementById('backgroundMusic');
      bgMusic.volume = 0.1; // Set low volume
      bgMusic.play();
    }

    function startTimer() {
      gameTimer = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          checkGameOver();
        }
        updateGameInfo();
      }, 1000);
    }

    function updateGameInfo() {
      document.getElementById('leftInfo').textContent = `Round: ${round} | Time: ${timeLeft}`;
      document.getElementById('rightInfo').textContent = `Shots: ${shotsLeft} | Score: ${score % 10}`;
    }

    function shoot() {
      if (gameOver) return;
      if (shotsLeft <= 0) return;
      if (shellOnScreen) return;

      shotsLeft--;
      updateGameInfo();

      let shellX = cannon.x + cannon.width / 2;
      let shellY = cannon.y;

      let shell = new Shell(shellX, shellY);
      shells.push(shell);
      shellOnScreen = true;

      checkGameOver();
    }

    function handleShootEvent(event) {
      event.preventDefault();
      shoot();
    }

    document.getElementById('shootButton').addEventListener('click', shoot);
    window.addEventListener('keydown', function(event) {
      if (event.code === 'Space') {
        shoot();
      }
    });
    canvas.addEventListener('touchstart', handleShootEvent);

    function checkCollision(shell) {
      // Collision with upper beam
      if (!shell.bounced && shell.y - shell.radius <= upperBeam.y + upperBeam.height && shell.x >= upperBeam.x && shell.x <= upperBeam.x + upperBeam.width) {
        shell.speedY *= -1;
        shell.bounced = true;
        shell.bouncedFromUpperBeam = true;
        shell.y = upperBeam.y + upperBeam.height + shell.radius;
      }

      // Collision with lower beam of the wagon
      let lowerBeamY = wagon.y + wagon.height;
      let lowerBeamHeight = canvas.height * 0.01;
      if (!shell.bounced && shell.y - shell.radius <= lowerBeamY + lowerBeamHeight && shell.y + shell.radius >= lowerBeamY && shell.x >= wagon.x && shell.x <= wagon.x + wagon.width) {
        shell.speedY *= -1;
        shell.bounced = true;
        shell.bouncedFromUpperBeam = false;
        shell.y = lowerBeamY + lowerBeamHeight + shell.radius;
      }

      // Collision with the wagon
      if (shell.y + shell.radius >= wagon.y && shell.y - shell.radius <= wagon.y + wagon.height && shell.x >= wagon.x && shell.x <= wagon.x + wagon.width) {
        if (shell.speedY > 0 && shell.bouncedFromUpperBeam) {
          // Successful hit
          score++;
          updateGameInfo();
          shell.active = false;
          shellOnScreen = false;

          if (score % 10 === 0 && score !== 0) {
            nextRound();
          }
        } else if (shell.speedY < 0) {
          // Bounce off the bottom
          shell.speedY *= -1;
          shell.bounced = true;
          shell.bouncedFromUpperBeam = false;
          shell.y = wagon.y + wagon.height + shell.radius;
        } else {
          // If shell didn't bounce from upper beam, it disappears
          shell.active = false;
          shellOnScreen = false;
        }
      }
    }

    function nextRound() {
      round++;
      if (round > maxRounds) {
        gameOver = true;
        clearInterval(gameTimer);
        alert('Congratulations! You won!');
        return;
      }
      timeLeft = 90;
      shotsLeft = 20;
      updateGameInfo();
    }

    function checkGameOver() {
      let requiredScore = 10 * (round - 1) + 10;
      let possibleShots = shotsLeft + (shellOnScreen ? 1 : 0);
      let remainingHits = requiredScore - score;
      if ((possibleShots < remainingHits && score % 10 !== 0) || (shotsLeft <= 0 && score % 10 !== 0) || timeLeft <= 0) {
        gameOver = true;
        clearInterval(gameTimer);
        alert('Game Over! You did not reach the target.');
      }
    }

    function gameLoop() {
      if (gameOver) return;

      context.clearRect(0, 0, canvas.width, canvas.height);

      mountains.forEach(mountain => mountain.draw());

      clouds.forEach(cloud => {
        cloud.update();
        cloud.draw();
      });

      upperBeam.draw();

      wagon.update();
      wagon.draw();

      cannon.update();
      cannon.draw();

      shells.forEach(shell => {
        shell.update();
        checkCollision(shell);
        shell.draw();
      });

      shells = shells.filter(shell => shell.active);

      requestAnimationFrame(gameLoop);
    }

    initGame();
    gameLoop();
  </script>
</body>
</html>
