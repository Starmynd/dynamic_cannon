<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Dynamic Cannon</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #gameCanvas {
      display: block;
      background: #87CEEB; /* Небесно-голубой фон */
    }
    #gameInfo {
      position: absolute;
      bottom: 50px; /* Над кнопкой "Shoot" */
      width: 100%;
      display: flex;
      justify-content: space-between;
      padding: 0 10px;
      font-size: 18px;
      font-family: sans-serif;
      color: #000;
    }
    #shootButton {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 50px;
      font-size: 24px;
      background-color: #4CAF50;
      color: white;
      border: none;
      outline: none;
      cursor: pointer;
    }
    #shootButton:active {
      background-color: #45a049;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="gameInfo">
    <div id="leftInfo">Раунд: 1 | Время: 90</div>
    <div id="rightInfo">Выстрелы: 20 | Счет: 0</div>
  </div>
  <button id="shootButton">Shoot</button>
  <script>
    const canvas = document.getElementById('gameCanvas');
    const context = canvas.getContext('2d');

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - 50; // Учитываем высоту кнопки
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    class Cannon {
      constructor() {
        this.width = canvas.width * 0.08;
        this.height = canvas.height * 0.05;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height - this.height;
        this.speed = canvas.width * 0.003; // Скорость пропорциональна ширине экрана
        this.direction = 1; // 1 - вправо, -1 - влево
      }
      update() {
        this.x += this.speed * this.direction;
        if (this.x <= 0) {
          this.x = 0;
          this.direction *= -1;
        }
        if (this.x + this.width >= canvas.width) {
          this.x = canvas.width - this.width;
          this.direction *= -1;
        }
      }
      draw() {
        context.fillStyle = '#000';
        context.fillRect(this.x, this.y, this.width, this.height);
        // Рисуем ствол пушки
        context.fillRect(this.x + this.width / 2 - this.width * 0.05, this.y - this.height * 0.5, this.width * 0.1, this.height * 0.5);
      }
    }

    class Wagon {
      constructor() {
        this.width = canvas.width * 0.15;
        this.height = canvas.height * 0.05;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height * 0.55;
        this.speed = canvas.width * 0.002; // Скорость пропорциональна ширине экрана
        this.direction = 1; // 1 - вправо, -1 - влево
      }
      update() {
        this.x += this.speed * this.direction;
        if (this.x <= 0) {
          this.x = 0;
          this.direction *= -1;
        }
        if (this.x + this.width >= canvas.width) {
          this.x = canvas.width - this.width;
          this.direction *= -1;
        }
      }
      draw() {
        // Рисуем крепление к тросу
        context.strokeStyle = '#000';
        context.lineWidth = 2;
        context.beginPath();
        context.moveTo(this.x + this.width / 2, 0);
        context.lineTo(this.x + this.width / 2, this.y);
        context.stroke();

        // Рисуем корзину
        context.fillStyle = '#8B4513'; // Коричневый цвет
        context.fillRect(this.x, this.y, this.width, this.height);

        // Рисуем нижнюю балку
        context.fillStyle = '#555';
        context.fillRect(this.x, this.y + this.height, this.width, canvas.height * 0.01);
      }
    }

    class Shell {
      constructor(x, y) {
        this.radius = canvas.width * 0.015;
        this.x = x;
        this.y = y;
        this.speedY = -canvas.height * 0.008;
        this.bounced = false;
        this.active = true;
      }
      update() {
        this.y += this.speedY;
        if (this.y + this.radius * 2 < 0 || this.y - this.radius > canvas.height) {
          this.active = false;
        }
      }
      draw() {
        context.fillStyle = '#000';
        context.beginPath();
        context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        context.fill();
      }
    }

    class Beam {
      constructor() {
        this.width = canvas.width * 0.8;
        this.height = canvas.height * 0.01;
        this.x = (canvas.width - this.width) / 2;
        this.y = canvas.height * 0.1;
      }
      draw() {
        context.fillStyle = '#555';
        context.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    class Cloud {
      constructor(x, y, scale, speed) {
        this.x = x;
        this.y = y;
        this.scale = scale;
        this.speed = speed;
      }
      update() {
        this.x += this.speed;
        if (this.x - 100 * this.scale > canvas.width) {
          this.x = -100 * this.scale;
        }
      }
      draw() {
        context.fillStyle = '#FFF';
        context.beginPath();
        context.arc(this.x, this.y, 30 * this.scale, Math.PI * 0.5, Math.PI * 1.5);
        context.arc(this.x + 30 * this.scale, this.y - 30 * this.scale, 30 * this.scale, Math.PI * 1, Math.PI * 1.85);
        context.arc(this.x + 60 * this.scale, this.y - 20 * this.scale, 20 * this.scale, Math.PI * 1.37, Math.PI * 1.91);
        context.arc(this.x + 80 * this.scale, this.y, 30 * this.scale, Math.PI * 1.5, Math.PI * 0.5);
        context.closePath();
        context.fill();
      }
    }

    class Mountain {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      draw() {
        // Рисуем гору
        context.fillStyle = '#A0522D'; // Цвет сиены
        context.beginPath();
        context.moveTo(this.x, this.y);
        context.lineTo(this.x + this.width / 2, this.y - this.height);
        context.lineTo(this.x + this.width, this.y);
        context.closePath();
        context.fill();

        // Рисуем снежную шапку
        context.fillStyle = '#FFF';
        context.beginPath();
        context.moveTo(this.x + this.width / 2, this.y - this.height);
        context.lineTo(this.x + this.width * 0.6, this.y - this.height * 0.8);
        context.lineTo(this.x + this.width * 0.4, this.y - this.height * 0.8);
        context.closePath();
        context.fill();
      }
    }

    let shells = [];
    let clouds = [];
    let mountains = [];
    let cannon;
    let wagon;
    let upperBeam;

    let shotsLeft = 20;
    let score = 0;
    let round = 1;
    let timeLeft = 90;
    let maxRounds = 10;

    let gameOver = false;

    let lastTime = Date.now();
    let gameTimer;

    function initGame() {
      cannon = new Cannon();
      wagon = new Wagon();
      upperBeam = new Beam();

      // Инициализируем облака
      for (let i = 0; i < 5; i++) {
        let x = Math.random() * canvas.width;
        let y = canvas.height * 0.1 + Math.random() * canvas.height * 0.2;
        let scale = 0.5 + Math.random() * 0.5;
        let speed = 0.2 + Math.random() * 0.3;
        clouds.push(new Cloud(x, y, scale, speed));
      }

      // Инициализируем горы
      let mountainWidth = canvas.width / 4;
      let mountainHeight = canvas.height / 3;
      mountains.push(new Mountain(canvas.width * 0.1, canvas.height, mountainWidth, mountainHeight));
      mountains.push(new Mountain(canvas.width * 0.4, canvas.height, mountainWidth, mountainHeight * 1.2));
      mountains.push(new Mountain(canvas.width * 0.7, canvas.height, mountainWidth, mountainHeight * 0.8));

      updateGameInfo();
      startTimer();
    }

    function startTimer() {
      gameTimer = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          timeLeft = 0;
          checkGameOver();
        }
        updateGameInfo();
      }, 1000);
    }

    function updateGameInfo() {
      document.getElementById('leftInfo').textContent = `Раунд: ${round} | Время: ${timeLeft}`;
      document.getElementById('rightInfo').textContent = `Выстрелы: ${shotsLeft} | Счет: ${score % 10}`;
    }

    function shoot() {
      if (gameOver) return;
      if (shotsLeft <= 0) return;

      shotsLeft--;
      updateGameInfo();

      let shellX = cannon.x + cannon.width / 2;
      let shellY = cannon.y;

      let shell = new Shell(shellX, shellY);
      shells.push(shell);

      checkGameOver();
    }

    document.getElementById('shootButton').addEventListener('click', shoot);
    window.addEventListener('keydown', function(event) {
      if (event.code === 'Space') {
        shoot();
      }
    });

    function checkCollision(shell) {
      // Столкновение с верхней балкой
      if (!shell.bounced && shell.y - shell.radius <= upperBeam.y + upperBeam.height && shell.x >= upperBeam.x && shell.x <= upperBeam.x + upperBeam.width) {
        shell.speedY *= -1;
        shell.bounced = true;
        shell.y = upperBeam.y + upperBeam.height + shell.radius;
      }

      // Столкновение с нижней балкой корзины
      let lowerBeamY = wagon.y + wagon.height;
      let lowerBeamHeight = canvas.height * 0.01;
      if (!shell.bounced && shell.y - shell.radius <= lowerBeamY + lowerBeamHeight && shell.y + shell.radius >= lowerBeamY && shell.x >= wagon.x && shell.x <= wagon.x + wagon.width) {
        shell.speedY *= -1;
        shell.bounced = true;
        shell.y = lowerBeamY + lowerBeamHeight + shell.radius;
      }

      // Столкновение с корзиной
      if (shell.y - shell.radius <= wagon.y + wagon.height && shell.y + shell.radius >= wagon.y && shell.x >= wagon.x && shell.x <= wagon.x + wagon.width) {
        if (shell.speedY < 0 && shell.y + shell.radius <= wagon.y + wagon.height) {
          // Попадание в корзину сверху
          score++;
          updateGameInfo();
          shell.active = false;

          // Проверяем, набрал ли игрок 10 очков в текущем раунде
          if (score % 10 === 0 && score !== 0) {
            nextRound();
          }
        } else if (shell.speedY > 0 && shell.y - shell.radius >= wagon.y) {
          // Отскок от дна корзины
          shell.speedY *= -1;
          shell.y = wagon.y - shell.radius;
        }
      }
    }

    function nextRound() {
      round++;
      if (round > maxRounds) {
        gameOver = true;
        clearInterval(gameTimer);
        alert('Поздравляем! Вы победили!');
        return;
      }
      // Сбрасываем время и выстрелы
      timeLeft = 90;
      shotsLeft = 20;
      updateGameInfo();
    }

    function checkGameOver() {
      let requiredScore = 10 * (round - 1) + 10;
      let possibleShots = shotsLeft + shells.length;
      let remainingHits = requiredScore - score;
      if ((possibleShots < remainingHits && score % 10 !== 0) || (shotsLeft <= 0 && score % 10 !== 0) || timeLeft <= 0) {
        gameOver = true;
        clearInterval(gameTimer);
        alert('Игра окончена! Вы не смогли достичь цели.');
      }
    }

    function gameLoop() {
      if (gameOver) return;

      context.clearRect(0, 0, canvas.width, canvas.height);

      // Рисуем фон
      mountains.forEach(mountain => mountain.draw());

      clouds.forEach(cloud => {
        cloud.update();
        cloud.draw();
      });

      upperBeam.draw();

      wagon.update();
      wagon.draw();

      cannon.update();
      cannon.draw();

      // Обновляем и рисуем ядра
      shells.forEach(shell => {
        shell.update();
        checkCollision(shell);
        shell.draw();
      });

      // Удаляем неактивные ядра
      shells = shells.filter(shell => shell.active);

      requestAnimationFrame(gameLoop);
    }

    initGame();
    gameLoop();
  </script>
</body>
</html>
